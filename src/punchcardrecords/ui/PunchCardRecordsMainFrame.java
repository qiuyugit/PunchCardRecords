/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package punchcardrecords.ui;

import java.awt.Desktop;
import java.awt.Image;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.math.BigDecimal;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JProgressBar;
import javax.swing.filechooser.FileNameExtensionFilter;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.poi.hssf.usermodel.HSSFCellStyle;
import org.apache.poi.hssf.usermodel.HSSFPalette;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.poifs.filesystem.OfficeXmlFileException;
import org.apache.poi.ss.usermodel.IndexedColors;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFColor;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import punchcardrecords.common.CommonPrintStream;
import punchcardrecords.common.PropertyUtils;


/**
 *
 * @author Administrator
 */
public class PunchCardRecordsMainFrame extends javax.swing.JFrame {

    /**
     * Creates new form PunchCardRecordsMainFrame
     */
    public PunchCardRecordsMainFrame() {
        initComponents();
        redirectSyetemPrint();
        initProcessBar();
    }
    
    /**
     * 初始化进度条
     */
    private void initProcessBar(){
        progressBar.setOrientation(JProgressBar.HORIZONTAL);
        progressBar.setStringPainted(true);
        progressBar.setMinimum(0);
        progressBar.setMaximum(100);
        progressBar.setValue(0);
        progressBar.setString("尚未开始解析任何文件");
    }
    
    /**
     * 将系统打印重定向到自己的组件中
     */
    private void redirectSyetemPrint(){
        printStream = new CommonPrintStream(System.out, statusView);
        System.setOut(printStream);  
        //System.setErr(printStream);
    }
    
    /**
     * 创面面板时需要初始化的设置
     */
    public void init(){
        // 设置版本标题
        this.setTitle(PropertyUtils.instanceVersion().getName());
        abort = new Abort(this);
        try {
            // 设置窗体图标
            Image logo = ImageIO.read(this.getClass().getResource("/resources/image/logo.png"));
            if(null != logo){
                this.setIconImage(logo);
            }
        } catch (IOException ex) {
            Logger.getLogger(PunchCardRecordsMainFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
        // 设置窗体在屏幕中间显示
        this.setLocationRelativeTo(null);
        this.setVisible(true);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        infoBottom = new javax.swing.JLabel();
        doWithLabel = new javax.swing.JLabel();
        fileName = new javax.swing.JLabel();
        parseInfoPanel = new javax.swing.JScrollPane();
        statusView = new javax.swing.JTextArea();
        copyRight = new javax.swing.JLabel();
        progressBar = new javax.swing.JProgressBar();
        menuBar = new javax.swing.JMenuBar();
        menuFile = new javax.swing.JMenu();
        singleMonth = new javax.swing.JMenuItem();
        wholeYear = new javax.swing.JMenuItem();
        menuAbort = new javax.swing.JMenu();
        menuItemInfo = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setName("mainFrame"); // NOI18N
        setResizable(false);

        infoBottom.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        infoBottom.setText("授权@世界上最可爱永远18岁的HR孙蓉蓉使用");

        doWithLabel.setText("正在处理文件:");

        statusView.setEditable(false);
        statusView.setColumns(20);
        statusView.setRows(5);
        parseInfoPanel.setViewportView(statusView);

        copyRight.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        copyRight.setText("Copyright © 2016 Dev QiuYu. All rights reserved.");

        menuFile.setText("文件");

        singleMonth.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F, java.awt.event.InputEvent.ALT_MASK));
        singleMonth.setIcon(copyRight.getIcon());
        singleMonth.setText("单月考勤统计");
        singleMonth.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                singleMonthActionPerformed(evt);
            }
        });
        menuFile.add(singleMonth);

        wholeYear.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_A, java.awt.event.InputEvent.ALT_MASK));
        wholeYear.setText("年度考勤统计");
        wholeYear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                wholeYearActionPerformed(evt);
            }
        });
        menuFile.add(wholeYear);

        menuBar.add(menuFile);

        menuAbort.setText("关于");

        menuItemInfo.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_I, java.awt.event.InputEvent.ALT_MASK));
        menuItemInfo.setText("软件信息");
        menuItemInfo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuItemInfoActionPerformed(evt);
            }
        });
        menuAbort.add(menuItemInfo);

        menuBar.add(menuAbort);

        setJMenuBar(menuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(copyRight, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(infoBottom, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(layout.createSequentialGroup()
                .addGap(31, 31, 31)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(parseInfoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 441, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(doWithLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(fileName, javax.swing.GroupLayout.PREFERRED_SIZE, 343, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(progressBar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(0, 31, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(doWithLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(fileName, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(parseInfoPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 217, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(copyRight, javax.swing.GroupLayout.PREFERRED_SIZE, 15, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(4, 4, 4)
                .addComponent(infoBottom)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    
    /**
     * 根据给定的进度判断进度条的增加
     * @param process 要更新的进度 
     */
    private void addBar(final int process){
        new Thread(new Runnable() {

            @Override
            public void run() {
                int value = progressBar.getValue();
                // 线程中使用外部函数的变量需要将其静态化
                progressBar.setValue(value+process);
                DecimalFormat df = new DecimalFormat("#0.00");
                progressBar.setString("解析已完成:"+df.format(progressBar.getPercentComplete()*100)+"%");
            }
        }).start();
    }
    
    /**
     * 单月考勤统计菜单响应事件
     * @param evt 
     */
    private void singleMonthActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_singleMonthActionPerformed
        new Thread(new Runnable() {

            @Override
            public void run() {
                // 菜单点击事件
                JFileChooser fileChooser =  new JFileChooser();
                fileChooser.setAcceptAllFileFilterUsed(false);
                String[] saveType = {"xls","xlsx"};
                fileChooser.setFileFilter(new FileNameExtensionFilter("*.xls,*.xlsx",saveType));
                int selectResult = fileChooser.showDialog(null, "选择");
                if(selectResult == JFileChooser.APPROVE_OPTION){
                    File file=fileChooser.getSelectedFile();
                    if(null!=file && file.exists()){
                        String selectedFileName = file.getName();
                        String regex = selectedFileName.split("\\.")[1];
                        if("xlsx".equals(regex) || "xls".equals(regex)){
                            fileName.setText(selectedFileName);
                            clearMessage();
                            addMessage("开始处理文件:"+selectedFileName);
                            addMessage("正在读取文件:"+selectedFileName);
                            if("xls".equals(regex)){
                                parseExcel42003(file);
                            }else if("xlsx".equals(regex)){
                                parseExcel42007(file);
                            }
                        }else{
                            alert("文件格式不支持,请选择Excel文件!");
                        }
                    }
                }
            }
        }).start();
    }//GEN-LAST:event_singleMonthActionPerformed
    
    /**
     * 年度考勤统计菜单响应事件
     * @param evt 
     */
    private void wholeYearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_wholeYearActionPerformed
       new Thread(new Runnable() {

           @Override
           public void run() {
                // 菜单点击事件
                JFileChooser fileChooser =  new JFileChooser();
                fileChooser.setAcceptAllFileFilterUsed(false);
                fileChooser.setMultiSelectionEnabled(true);
                String[] saveType = {"xls","xlsx"};
                fileChooser.setFileFilter(new FileNameExtensionFilter("*.xls,*.xlsx",saveType));
                int selectResult = fileChooser.showDialog(null, "选择");
                if(selectResult == JFileChooser.APPROVE_OPTION){
                    File[] files=fileChooser.getSelectedFiles();
                    if(files != null){
                        clearMessage();// 清除显示消息
                        progressBar.setMaximum(files.length);
                        Map<String,double[]> result = new HashMap<String,double[]>();
                        // 开始批量储量出文件
                        for(File file : files){
                           if(null!=file && file.exists()){
                                String selectedFileName = file.getName();
                                String regex = selectedFileName.split("\\.")[1];
                                if("xlsx".equals(regex) || "xls".equals(regex)){
                                    fileName.setText(selectedFileName);
                                    addMessage("开始处理文件:"+selectedFileName);
                                    addMessage("正在读取文件");
                                    if("xls".equals(regex)){
                                        result = conactPunchRecords(result, parseExcelYear42003(file) );
                                    }else if("xlsx".equals(regex)){
                                        result = conactPunchRecords(result, parseExcelYear42007(file) );
                                    }
                                }else{
                                   alert("文件格式不支持,请选择Excel文件!");
                                }
                            }
                            // 更新解析进度条
                            addBar(1);
                        }
                        // 获取一个文件的路径,根据文件的路径生成结果文档
                        File file = files[0];
                        String path = file.getAbsolutePath().substring(0,file.getAbsolutePath().lastIndexOf("\\"));
                        // 开始写入结果
                        writeYearCountResult(result,path);
                    }
                }
           }
       }).start();
    }//GEN-LAST:event_wholeYearActionPerformed

    private void menuItemInfoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuItemInfoActionPerformed
        abort.setVisible(true);
    }//GEN-LAST:event_menuItemInfoActionPerformed

    /**
     * 将年度结果写入到一个新的Excel中
     * @param year 
     */
    private void writeYearCountResult(Map<String,double[]> yearRecords,String path){
        XSSFWorkbook resultWorkBook = new XSSFWorkbook();
        XSSFSheet sheet = resultWorkBook.createSheet();
        Set<String> userNumNames = yearRecords.keySet();
        // 在第一行创建表头
        String[] titles = {"员工工号","员工姓名","出勤天数(天)","出勤时间(小时)","平均出勤(小时)"};
        int col = 0;// 列
        XSSFRow titleRow = sheet.createRow(0);
        for(String title : titles){
            titleRow.createCell(col).setCellValue(title);
            sheet.autoSizeColumn((short)(col));
            col++;
        }
        int row = 1;// 行
        // 开始循环员工
        for(String userStr : userNumNames){
            XSSFRow recordRow = sheet.createRow(row);
            int innerCol = 0;// 当前行的列
            // 写入员工信息
            String[] userInfos = userStr.split(":");
            for(String userInfo : userInfos){
                recordRow.createCell(innerCol).setCellValue(userInfo);
                innerCol++;
            }
            // 写入员工考勤记录
            double[] records = yearRecords.get(userStr);
            for(double record : records){
                recordRow.createCell(innerCol).setCellValue(record);
                innerCol++;
            }
            // 写入员工年度平均出勤记录
            recordRow.createCell(innerCol).setCellValue(new BigDecimal(records[0]==0?0:records[1]/records[0]).setScale(1, BigDecimal.ROUND_HALF_UP).doubleValue());
            row++;
        }
        
        // 打开另存为保存对话框,准备获取保存路径
        JFileChooser fileSaveChooser =  new JFileChooser();

        fileSaveChooser.setDialogTitle("另存为");
        fileSaveChooser.setSelectedFile(new File(path+"/年度考勤统计.xlsx"));
        String[] saveType = {"xlsx"};
        fileSaveChooser.setAcceptAllFileFilterUsed(false);
        fileSaveChooser.setFileFilter(new FileNameExtensionFilter("*.xlsx",saveType));
        int saveResult = fileSaveChooser.showSaveDialog(this);
        if(saveResult == JFileChooser.APPROVE_OPTION){
            File saveFile = fileSaveChooser.getSelectedFile();

            // 将副本复制到指定的保存位置
            String saveFilePath = saveFile.getAbsolutePath();
            addMessage("正在保存文件,请稍后->"+saveFilePath);
            FileOutputStream out = null;
            try {
                out = new FileOutputStream(saveFile);
                resultWorkBook.write(out);
                out.close();
            } catch (FileNotFoundException ex) {
                Logger.getLogger(PunchCardRecordsMainFrame.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IOException ex) {
                Logger.getLogger(PunchCardRecordsMainFrame.class.getName()).log(Level.SEVERE, null, ex);
            } finally {
                try {
                    if(out != null){
                        out.close();
                    }
                } catch (IOException ex) {
                    Logger.getLogger(PunchCardRecordsMainFrame.class.getName()).log(Level.SEVERE, null, ex);
                }
            }

            Object[] options = {"打开文件","打开文件所在目录","别烦我,我要自己去找"};
            int response=JOptionPane.showOptionDialog(this, "文件处理完成,接下来你要进行哪步处理", "操作选择",JOptionPane.YES_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
            if(0 == response){// 打开文件
                // 打开文件保存保存的文件
                addMessage("正在打开文件,请稍后");
                try {
                    Desktop.getDesktop().open(saveFile);
                } catch (IOException ex) {
                    Logger.getLogger(PunchCardRecordsMainFrame.class.getName()).log(Level.SEVERE, null, ex);
                }
            }else if(1 == response){// 正在打开文件所在目录
                addMessage("正在打开文件所在目录,请稍后");
                String[] cmd = new String[5];
                cmd[0] = "cmd";
                cmd[1] = "/c";
                cmd[2] = "start";
                cmd[3] = " ";
                cmd[4] = saveFile.getAbsolutePath().substring(0,saveFile.getAbsolutePath().lastIndexOf("\\"));
                try {
                    Runtime.getRuntime().exec(cmd);
                } catch (IOException ex) {
                    Logger.getLogger(PunchCardRecordsMainFrame.class.getName()).log(Level.SEVERE, null, ex);
                }
            }else{
                alert("文件解析已完成,任性的你自己去找吧╮(╯▽╰)╭");
            }
        }else{
            // 如果取消保存,则清除所有消息并置空文件头
            clearMessage();
            fileName.setText("");
            // 通知用户当前文件已取消保存
            addMessage("用户已取消操作");
        }
    }
    
    /**
     * 将单月考勤记录结果合并到的年度考勤结果中
     * @param year 年度考勤记录
     * @param singleMonth 单月考勤记录
     * @return 合并单月记录后的年度记录
     */
    private Map<String,double[]> conactPunchRecords(Map<String,double[]> year, Map<String,double[]> singleMonth){
        Set<String> keys = singleMonth.keySet();
        for(String key : keys){
            if(year.containsKey(key)){
                double[] yearRecords = year.get(key);
                double[] monthRecords = singleMonth.get(key);
                for(int i=0;i<yearRecords.length;i++){
                    yearRecords[i] = yearRecords[i] + monthRecords[i];
                }
                year.put(key,yearRecords);
            }else{
                double[] monthRecords = singleMonth.get(key);
                double[] yearRecords = {monthRecords[0],monthRecords[1]};
                year.put(key,yearRecords);
            }
        }
        return year;
    }
    
    /**
     * 弹出提示框
     * @param message 要弹出提示的消息
     */
    private void alert(String message){
         JOptionPane.showMessageDialog(this, message);
    }
    
    /**
     * 给定文件,解析文件中的员工的考勤
     * @param excelFile 要解析的文件,2003-2007版本excel
     * @return 解析结果
     */
    private Map<String,double[]> parseExcelYear42003(File excelFile){
        return parseExcel42003(excelFile,false);
    }
    
    /**
     * 给定文件,解析文件中的员工的考勤
     * @param excelFile 要解析的文件,2007+版本excel
     * @return 解析结果
     */
    private Map<String,double[]> parseExcelYear42007(File excelFile){
        return parseExcel42007(excelFile,false);
    }
    
    /**
     * 根据给定的月份判断当前年月日下是否为周末
     * @param month 正常月份
     * @param day 正常的月份内的日期
     * @return 
     */
    private boolean isWeekEnd(int year,int month,int day){
       Calendar calendar = Calendar.getInstance();
       calendar.set(year, month-1, day);
       return calendar.get(Calendar.DAY_OF_WEEK)==Calendar.SUNDAY || calendar.get(Calendar.DAY_OF_WEEK)==Calendar.SATURDAY;
    }
    
    /**
     * 解析excel文件(2007+),单月处理
     * @param excelFile 要解析的Excel文件对象
     * @param single 是否是单月
     */
    private Map<String,double[]> parseExcel42007(File excelFile){
        return parseExcel42007(excelFile,true);
    }
    
    /**
     * 解析excel文件(2007+)
     * @param excelFile 要解析的Excel文件对象
     * @param single 是否是单月
     */
    private Map<String,double[]> parseExcel42007(File excelFile, boolean single){
        Map<String,double[]> result = new HashMap<String,double[]>();
        try {
            // 复制一份文件,读源文件,写文件副本
            File copyExcelFile = null;
            XSSFWorkbook copyWorkBook = null;
            if(single){// 单月的特殊处理
                addMessage("创建文件副本");
                copyExcelFile = new File(excelFile.getAbsolutePath().substring(0,excelFile.getAbsolutePath().lastIndexOf("\\"))+"/考勤副本.xlsx");
                FileUtils.copyFile(excelFile, copyExcelFile);
                // 创建副本的工作薄用于改写
                copyWorkBook = new XSSFWorkbook(new FileInputStream(copyExcelFile));
            }
            
            // 开始读源文件
            XSSFWorkbook workBook = new XSSFWorkbook(new FileInputStream(excelFile));
            XSSFSheet sheet = workBook.getSheetAt(0);
            int rows = sheet.getLastRowNum();
            if(rows>=6){ // 如果行数大于6,说明才包含员工信息
                int month = -1; // 当前考勤属于哪个月份
                int year = -1;// 当前考勤属于哪一年
                if(single){// 单月的特殊处理
                    // 首先取第3行,看是哪个日期的考勤数据
                    String dateStr = sheet.getRow(2).getCell(2).getStringCellValue();
                    if(StringUtils.isNotBlank(dateStr)){
                        addMessage("当前解析的考勤记录时间范围为:"+dateStr);
                        String[] dates = dateStr.split("~");
                        month = Integer.parseInt(dates[0].split("\\/")[1]);// 获取当前考勤所属月份
                        year = Integer.parseInt(dates[0].split("\\/")[0]);// 获取当前考勤所属年份
                    }else{
                        addMessage("未能获取当前考勤记录所属月份,将不能统计加班记录,如有需要请手动统计");
                    }
                    // 单月时,改变进度条的最大刻度值
                    // 从第六行开始,每两行才是一个员工
                    int maxValue = (rows-6)/2;
                    progressBar.setMaximum(maxValue);
                }
                int days = sheet.getRow(3).getLastCellNum();
                
                // 定义出勤时间解析器
                SimpleDateFormat punchFormat = new SimpleDateFormat("HH:mm");
                
                if(single){// 单月的特殊处理
                    // 给第五行最右侧加入三列表头,出勤天数,出勤时间,平均出勤时间
                    String[] title = {"出勤天数","出勤时间","平均出勤时间"};
                    if(null != copyWorkBook){
                        for(int i=0;i<title.length;i++){
                            copyWorkBook.getSheetAt(0).getRow(4).createCell(days+i).setCellValue(title[i]);
                            XSSFCellStyle cellStyle = (XSSFCellStyle)copyWorkBook.getSheetAt(0).getRow(4).getCell(0).getCellStyle().clone();
                            cellStyle.setFillPattern(XSSFCellStyle.SOLID_FOREGROUND );
                            cellStyle.setFillForegroundColor(IndexedColors.WHITE.getIndex());
                            copyWorkBook.getSheetAt(0).getRow(4).getCell(days+i).setCellStyle(cellStyle);
                            copyWorkBook.getSheetAt(0).autoSizeColumn((short)(days+i));
                        }
                    }
                }
                
                for(int i = 4; i<rows; i=i+2){ // 从第五行开始进行统计筛选
                    //从第五行开始,为正式的考勤记录,每次循环行数+2至下一个员工
                    String userName = sheet.getRow(i).getCell(10).getStringCellValue();// 员工姓名
                    String userNum = sheet.getRow(i).getCell(2).getStringCellValue();// 员工工号
                    if(single){// 单月的特殊处理
                        addMessage("正在解析员工:"+userName+"<工号:"+userNum+">");
                        // 变更解析进度
                        addBar(1);
                    }
                    
                    // 获取员工的打卡记录行,i+1
                    XSSFRow recordRow = sheet.getRow(i+1);

                    // 统计员工当月出勤天数
                    double punchDays = 0;
                    // 出勤时间(按小时算),平均出勤时间
                    double punchHours = 0,avgHours = 0;
                    // 解析员工每一天的打卡记录情况
                    for(int j=0;j<days;j++){// 开始读取每一天的数据
                        
                        if(single){// 单月的特殊处理
                            // 判断是否是周末,对周末进行颜色标识
                            // 如果年月都没有获取到,那么不进行是否周末的判断,只统计考勤数量
                            if(month!=-1 && year!=-1){
                                // 首先获取判断当前的日期是否为周末
                                if(isWeekEnd(year, month, j+1)){
                                    // 如果是周末,设置背景颜色为黄色
                                    if(null != copyWorkBook){
                                        XSSFCellStyle weekend = (XSSFCellStyle)copyWorkBook.getSheetAt(0).getRow(i+1).getCell(j).getCellStyle().clone();
                                        weekend.setFillPattern(XSSFCellStyle.SOLID_FOREGROUND );
                                        weekend.setFillForegroundColor(new XSSFColor(new java.awt.Color(21, 225, 216)));
                                        //weekend.setFillForegroundColor(IndexedColors.YELLOW.getIndex());
                                        copyWorkBook.getSheetAt(0).getRow(i+1).getCell(j).setCellStyle(weekend);
                                    }
                                }
                            }
                        }
                        
                        
                        // 开始解析当前日期的员工打卡记录
                        String record = recordRow.getCell(j).getStringCellValue();// 打卡记录
                        if(StringUtils.isNotBlank(record)){// 如果打卡记录不为空,开始解析打卡记录
                            String[] records = record.split("\n");
                            // 如果当前的打卡记录大于两条记录,则算为一天,并且统计打卡时间段
                            if(records.length>=2){
                                try {
                                    // 打卡开始时间start,结束时间end,午饭开始时间ls,午饭结束时间le
                                    Date end = punchFormat.parse(records[records.length-1]), start = punchFormat.parse(records[0]);
                                    Date ls = punchFormat.parse("11:40"),le = punchFormat.parse("13:00");
                                    
                                    if(start.after(ls) && end.before(le)){ 
                                        // 非正常打卡时间范围的,不统计考勤记录并且做特殊标记
                                        if(single){// 单月的特殊处理
                                            // 如果年月都没有获取到,那么不进行是否周末的判断,只统计考勤数量
                                            if(null != copyWorkBook){
                                                XSSFCellStyle excepitonStyle = (XSSFCellStyle)copyWorkBook.getSheetAt(0).getRow(i+1).getCell(j).getCellStyle().clone();
                                                excepitonStyle.setFillPattern(XSSFCellStyle.SOLID_FOREGROUND );
                                                if(month!=-1 && year!=-1){
                                                    // 首先获取判断当前的日期是否为周末
                                                    if(isWeekEnd(year, month, j+1)){
                                                        // 如果是周末,设置背景颜色为粉红色
                                                        excepitonStyle.setFillForegroundColor(IndexedColors.PINK.getIndex());
                                                    }else{
                                                        excepitonStyle.setFillForegroundColor(IndexedColors.RED.getIndex());
                                                    }
                                                }
                                                copyWorkBook.getSheetAt(0).getRow(i+1).getCell(j).setCellStyle(excepitonStyle);
                                            }
                                        }
                                    }else{//只有打卡时间在正常范围的才被统计考勤
                                        punchDays = punchDays + 1;
                                        // 计算当前的出勤时间
                                        long ms = end.getTime() - start.getTime();//每天的考勤时间要减掉吃饭时间
                                        
                                        // 如果上班时间早于吃饭开始时间,下班时间晚于午饭结束时间,吃饭时间为正常时间
                                        long mins = 75 * 60 *1000;//正常吃饭时间为75分钟
                                        
                                        // 如果上班时间早于吃饭开始时间,下班时间早于午饭结束时间
                                        if(start.before(ls) && end.before(le)){
                                            // 吃饭时间为下班时间减去吃饭开始时间
                                            mins = end.getTime() - ls.getTime();
                                        }
                                        
                                        // 如果上班时间晚于吃饭开始时间,下班时间晚于午饭结束时间
                                        if(start.after(ls) && end.after(le)){
                                            // 如果上班时间早于午饭结束时间,吃饭时间为:午饭结束时间-上班时间
                                            if(start.before(le)){
                                                mins = le.getTime() - start.getTime();
                                            }else if (start.after(ls)){ // 上班时间晚于午饭结束时间,午饭时间为0
                                                mins = 0;
                                            }
                                        }
                                        
                                        ms = ms - mins;// 扣减吃饭时间
                                        
                                        punchHours = punchHours + (double)ms/(3600*1000); // 累加工作时间(小时制)
                                    }
                                } catch (ParseException ex) {
                                    Logger.getLogger(PunchCardRecordsMainFrame.class.getName()).log(Level.SEVERE, null, ex);
                                }
                            }else{// 打卡记录异常的,则进行颜色设置
                                if(single){// 单月的特殊处理
                                    // 如果年月都没有获取到,那么不进行是否周末的判断,只统计考勤数量
                                    if(null != copyWorkBook){
                                        XSSFCellStyle excepitonStyle = (XSSFCellStyle)copyWorkBook.getSheetAt(0).getRow(i+1).getCell(j).getCellStyle().clone();
                                        excepitonStyle.setFillPattern(XSSFCellStyle.SOLID_FOREGROUND );
                                        if(month!=-1 && year!=-1){
                                            // 首先获取判断当前的日期是否为周末
                                            if(isWeekEnd(year, month, j+1)){
                                                // 如果是周末,设置背景颜色为粉红色
                                                excepitonStyle.setFillForegroundColor(IndexedColors.PINK.getIndex());
                                            }else{
                                                excepitonStyle.setFillForegroundColor(IndexedColors.RED.getIndex());
                                            }
                                        }
                                        copyWorkBook.getSheetAt(0).getRow(i+1).getCell(j).setCellStyle(excepitonStyle);
                                    }
                                }
                            }
                        }
                    }
                    // 计算平均出勤时间
                    if(punchDays>0){
                        // 工作时间四舍五入保留一位小数
                        punchHours = new BigDecimal(punchHours).setScale(1, BigDecimal.ROUND_HALF_UP).doubleValue();
                        avgHours = new BigDecimal(punchHours/punchDays).setScale(1, BigDecimal.ROUND_HALF_UP).doubleValue();
                    }
                    
                    double[] values = {punchDays,punchHours,avgHours};
                    result.put(userNum+":"+userName, values);
                    
                    if(single){// 单月的特殊处理
                        addMessage("员工:" + userName + "<工号:" + userNum + ">解析完成,出勤情况:" + "D:" + punchDays + ",H:" + punchHours + ",AH:" + avgHours);
                        if(null != copyWorkBook){
                            for(int v=0;v<values.length;v++){
                                copyWorkBook.getSheetAt(0).getRow(i+1).createCell(days+v).setCellValue(values[v]);
                                XSSFCellStyle cellStyle = (XSSFCellStyle)copyWorkBook.getSheetAt(0).getRow(i+1).getCell(0).getCellStyle().clone();
                                cellStyle.setFillPattern(XSSFCellStyle.SOLID_FOREGROUND );
                                cellStyle.setFillForegroundColor(IndexedColors.WHITE.getIndex());
                                copyWorkBook.getSheetAt(0).getRow(i+1).getCell(days+v).setCellStyle(cellStyle);
                            }
                        }
                    }
                }
                
                if(single){// 单月的特殊处理
                    // 读写完成操作开始
                    // 写入文件,并关闭写入流
                    addMessage("整在写入数据,请稍后");
                    if(null != copyWorkBook){
                        FileOutputStream out = new FileOutputStream(copyExcelFile);
                        copyWorkBook.write(out);
                        out.close();
                    }
                    
                    // 打开另存为保存对话框,准备获取保存路径
                    JFileChooser fileSaveChooser =  new JFileChooser();

                    fileSaveChooser.setDialogTitle("另存为");
                    fileSaveChooser.setSelectedFile(new File(excelFile.getAbsolutePath().substring(0,excelFile.getAbsolutePath().lastIndexOf("."))+"-计算结果.xlsx"));
                    String[] saveType = {"xlsx"};
                    fileSaveChooser.setAcceptAllFileFilterUsed(false);
                    fileSaveChooser.setFileFilter(new FileNameExtensionFilter("*.xlsx",saveType));
                    int saveResult = fileSaveChooser.showSaveDialog(this);
                    if(saveResult == JFileChooser.APPROVE_OPTION){
                        File saveFile = fileSaveChooser.getSelectedFile();

                        // 将副本复制到指定的保存位置
                        String saveFilePath = saveFile.getAbsolutePath();
                        addMessage("正在保存文件,请稍后->"+saveFilePath);
                        FileUtils.copyFile(copyExcelFile, saveFile);

                        Object[] options = {"打开文件","打开文件所在目录","别烦我,我要自己去找"};
                        int response=JOptionPane.showOptionDialog(this, "文件处理完成,接下来你要进行哪步处理", "操作选择",JOptionPane.YES_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
                        if(0 == response){// 打开文件
                            // 打开文件保存保存的文件
                            addMessage("正在打开文件,请稍后");
                            Desktop.getDesktop().open(saveFile);
                        }else if(1 == response){// 正在打开文件所在目录
                            addMessage("正在打开文件所在目录,请稍后");
                            String[] cmd = new String[5];
                            cmd[0] = "cmd";
                            cmd[1] = "/c";
                            cmd[2] = "start";
                            cmd[3] = " ";
                            cmd[4] = saveFile.getAbsolutePath().substring(0,saveFile.getAbsolutePath().lastIndexOf("\\"));
                            Runtime.getRuntime().exec(cmd);
                        }else{
                            alert("文件解析已完成,任性的你自己去找吧╮(╯▽╰)╭");
                        }
                    }else{
                        // 如果取消保存,则清除所有消息并置空文件头
                        clearMessage();
                        fileName.setText("");
                        // 通知用户当前文件已取消保存
                        addMessage("用户已取消操作");
                    }

                    // 在另存为结束后删除临时副本文件
                    if(null != copyExcelFile){
                        copyExcelFile.delete();
                    }
                }
                
                
            }else{
                // excel中不包含员工信息,那么提示不存在员工信息当前程序结束
                alert("当前的文件中不包含员工考勤记录信息!");
            }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(PunchCardRecordsMainFrame.class.getName()).log(Level.SEVERE, null, ex);
            alert("文件未找到,请检查文件是否已被删除或者移动位置");
        } catch (IOException | OfficeXmlFileException ex) {
            Logger.getLogger(PunchCardRecordsMainFrame.class.getName()).log(Level.SEVERE, null, ex);
            alert("文件读写异常:"+ex.getMessage());
        }
        return result;
    }
    
    /**
     * 解析excel文件(2003)
     * @param excelFile 要解析的Excel文件对象
     * @param single 是否是单月
     */
    private Map<String,double[]> parseExcel42003(File excelFile){
        return parseExcel42003(excelFile,true); 
    }
    /**
     * 解析excel文件(2003)
     * @param excelFile 要解析的Excel文件对象
     * @param single 是否是单月
     */
    private Map<String,double[]> parseExcel42003(File excelFile, boolean single){
        Map<String,double[]> result = new HashMap<String,double[]>();
        try {
            File copyExcelFile = null;
            HSSFWorkbook copyWorkBook = null;
            if(single){// 单月的特殊处理
                // 复制一份文件,读源文件,写文件副本
                addMessage("创建文件副本");
                copyExcelFile = new File(excelFile.getAbsolutePath().substring(0,excelFile.getAbsolutePath().lastIndexOf("\\"))+"/考勤副本.xlsx");
                FileUtils.copyFile(excelFile, copyExcelFile);
                // 创建副本的工作薄用于改写
                copyWorkBook = new HSSFWorkbook(new FileInputStream(copyExcelFile));
            }
            // 开始读源文件
            HSSFWorkbook workBook = new HSSFWorkbook(new FileInputStream(excelFile));
            HSSFSheet sheet = workBook.getSheetAt(0);
            int rows = sheet.getLastRowNum();
            if(rows>=6){ // 如果行数大于6,说明才包含员工信息
                // 首先取第3行,看是哪个日期的考勤数据
                String dateStr = sheet.getRow(2).getCell(2).getStringCellValue();
                int month = -1; // 当前考勤属于哪个月份
                int year = -1;// 当前考勤属于哪一年
                if(single){// 单月的特殊处理.
                    if(StringUtils.isNotBlank(dateStr)){
                        addMessage("当前解析的考勤记录时间范围为:"+dateStr);
                        String[] dates = dateStr.split("~");
                        month = Integer.parseInt(dates[0].split("\\/")[1]);// 获取当前考勤所属月份
                        year = Integer.parseInt(dates[0].split("\\/")[0]);// 获取当前考勤所属年份
                    }else{
                        addMessage("未能获取当前考勤记录所属月份,将不能统计加班记录,如有需要请手动统计");
                    }
                    // 单月时,改变进度条的最大刻度值
                    // 从第六行开始,每两行才是一个员工
                    int maxValue = (rows-6)/2;
                    progressBar.setMaximum(maxValue);
                }
                int days = sheet.getRow(3).getLastCellNum();
                
                // 定义出勤时间解析器
                SimpleDateFormat punchFormat = new SimpleDateFormat("HH:mm");
                
                // 给第五行最右侧加入三列表头,出勤天数,出勤时间,平均出勤时间
                String[] title = {"出勤天数","出勤时间","平均出勤时间"};
                if(single){// 单月的特殊处理
                    if(copyWorkBook != null){
                        for(int i=0;i<title.length;i++){
                            copyWorkBook.getSheetAt(0).getRow(4).createCell(days+i).setCellValue(title[i]);
                            HSSFCellStyle cellStyle = copyWorkBook.createCellStyle();
                            cellStyle.cloneStyleFrom(copyWorkBook.getSheetAt(0).getRow(4).getCell(0).getCellStyle());
                            cellStyle.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND );
                            cellStyle.setFillForegroundColor(IndexedColors.WHITE.getIndex());
                            copyWorkBook.getSheetAt(0).getRow(4).getCell(days+i).setCellStyle(cellStyle);
                            copyWorkBook.getSheetAt(0).autoSizeColumn((short)(days+i));
                        }
                    }
                }
                
                for(int i = 4; i<rows; i=i+2){ // 从第五行开始进行统计筛选
                    
                    //从第五行开始,为正式的考勤记录,每次循环行数+2至下一个员工
                    String userName = sheet.getRow(i).getCell(10).getStringCellValue();// 员工姓名
                    String userNum = sheet.getRow(i).getCell(2).getStringCellValue();// 员工工号
                    if(single){// 单月的特殊处理
                        addMessage("正在解析员工:"+userName+"<工号:"+userNum+">");
                        // 变更解析进度
                        addBar(1);
                    }
                    
                    // 获取员工的打卡记录行,i+1
                    HSSFRow recordRow = sheet.getRow(i+1);

                    // 统计员工当月出勤天数
                    double punchDays = 0;
                    // 出勤时间(按小时算),平均出勤时间
                    double punchHours = 0,avgHours = 0;
                    // 解析员工每一天的打卡记录情况
                    for(int j=0;j<days;j++){// 开始读取每一天的数据
                        if(single){// 单月的特殊处理
                            // 判断是否是周末,对周末进行颜色标识
                            // 如果年月都没有获取到,那么不进行是否周末的判断,只统计考勤数量
                            if(month!=-1 && year!=-1){
                                // 首先获取判断当前的日期是否为周末
                                if(isWeekEnd(year, month, j+1)){
                                    if(copyWorkBook != null){
                                        // 如果是周末,设置背景颜色为黄色
                                        HSSFCellStyle weekend = copyWorkBook.createCellStyle();
                                        weekend.cloneStyleFrom(copyWorkBook.getSheetAt(0).getRow(i+1).getCell(j).getCellStyle());
                                        weekend.setFillPattern(XSSFCellStyle.SOLID_FOREGROUND );
                                        HSSFPalette paltette = copyWorkBook.getCustomPalette();
                                        byte[] color = {(byte)(0xff&21),(byte)(0xff&225),(byte)(0xff&216)};
                                        paltette.setColorAtIndex((short)9, color[0], color[1], color[2]);
                                        weekend.setFillForegroundColor((short)9);
                                        copyWorkBook.getSheetAt(0).getRow(i+1).getCell(j).setCellStyle(weekend);
                                    }
                                }
                            }
                        }
                        
                        // 开始解析当前日期的员工打卡记录
                        String record = recordRow.getCell(j).getStringCellValue();// 打卡记录
                        if(StringUtils.isNotBlank(record)){// 如果打卡记录不为空,开始解析打卡记录
                            String[] records = record.split("\n");
                            // 如果当前的打卡记录大于两条记录,则算为一天,并且统计打卡时间段
                            if(records.length>=2){
                                try {
                                   // 打卡开始时间start,结束时间end,午饭开始时间ls,午饭结束时间le
                                    Date end = punchFormat.parse(records[records.length-1]), start = punchFormat.parse(records[0]);
                                    Date ls = punchFormat.parse("11:40"),le = punchFormat.parse("13:00");
                                    
                                    // 正常打卡时间:开始时间和结束时间不在吃饭时间内
                                    if(start.after(ls) && end.before(le)){ // 打卡时间在此时间内的是正常时间饭费
                                        if(single){// 单月的特殊处理
                                            if(null != copyWorkBook){
                                                // 如果年月都没有获取到,那么不进行是否周末的判断,只统计考勤数量
                                                HSSFCellStyle excepitonStyle = copyWorkBook.createCellStyle();
                                                excepitonStyle.cloneStyleFrom(copyWorkBook.getSheetAt(0).getRow(i+1).getCell(j).getCellStyle());
                                                excepitonStyle.setFillPattern(XSSFCellStyle.SOLID_FOREGROUND );
                                                if(month!=-1 && year!=-1){
                                                    // 首先获取判断当前的日期是否为周末
                                                    if(isWeekEnd(year, month, j+1)){
                                                        // 如果是周末,设置背景颜色为粉红色
                                                        excepitonStyle.setFillForegroundColor(IndexedColors.PINK.getIndex());
                                                    }else{
                                                        excepitonStyle.setFillForegroundColor(IndexedColors.RED.getIndex());
                                                    }
                                                }
                                                copyWorkBook.getSheetAt(0).getRow(i+1).getCell(j).setCellStyle(excepitonStyle);
                                            }
                                        }
                                    }else{ //只有打卡时间在正常范围的才被统计考勤
                                        punchDays = punchDays + 1;
                                        // 计算当前的出勤时间
                                        long ms = end.getTime() - start.getTime();//每天的考勤时间要减掉吃饭时间
                                        
                                        // 如果上班时间早于吃饭开始时间,下班时间晚于午饭结束时间,吃饭时间为正常时间
                                        long mins = 75 * 60 *1000;//正常吃饭时间为75分钟
                                        
                                        // 如果上班时间早于吃饭开始时间,下班时间早于午饭结束时间
                                        if(start.before(ls) && end.before(le)){
                                            // 吃饭时间为下班时间减去吃饭开始时间
                                            mins = end.getTime() - ls.getTime();
                                        }
                                        
                                        // 如果上班时间晚于吃饭开始时间,下班时间晚于午饭结束时间
                                        if(start.after(ls) && end.after(le)){
                                            // 如果上班时间早于午饭结束时间,吃饭时间为:午饭结束时间-上班时间
                                            if(start.before(le)){
                                                mins = le.getTime() - start.getTime();
                                            }else if (start.after(ls)){ // 上班时间晚于午饭结束时间,午饭时间为0
                                                mins = 0;
                                            }
                                        }
                                        
                                        ms = ms - mins;// 扣减吃饭时间
                                        
                                        punchHours = punchHours + (double)ms/(3600*1000); // 累加工作时间(小时制)
                                    }
                                } catch (ParseException ex) {
                                    Logger.getLogger(PunchCardRecordsMainFrame.class.getName()).log(Level.SEVERE, null, ex);
                                }
                            }else{// 打卡记录异常的,则进行颜色设置
                                if(single){// 单月的特殊处理
                                    if(null != copyWorkBook){
                                        // 如果年月都没有获取到,那么不进行是否周末的判断,只统计考勤数量
                                        HSSFCellStyle excepitonStyle = copyWorkBook.createCellStyle();
                                        excepitonStyle.cloneStyleFrom(copyWorkBook.getSheetAt(0).getRow(i+1).getCell(j).getCellStyle());
                                        excepitonStyle.setFillPattern(XSSFCellStyle.SOLID_FOREGROUND );
                                        if(month!=-1 && year!=-1){
                                            // 首先获取判断当前的日期是否为周末
                                            if(isWeekEnd(year, month, j+1)){
                                                // 如果是周末,设置背景颜色为粉红色
                                                excepitonStyle.setFillForegroundColor(IndexedColors.PINK.getIndex());
                                            }else{
                                                excepitonStyle.setFillForegroundColor(IndexedColors.RED.getIndex());
                                            }
                                        }
                                        copyWorkBook.getSheetAt(0).getRow(i+1).getCell(j).setCellStyle(excepitonStyle);
                                    }
                                }
                            }
                        }
                    }
                    // 计算平均出勤时间
                    if(punchDays>0){
                        // 工作时间四舍五入保留一位小数
                        punchHours = new BigDecimal(punchHours).setScale(1, BigDecimal.ROUND_HALF_UP).doubleValue();
                        avgHours = new BigDecimal(punchHours/punchDays).setScale(1, BigDecimal.ROUND_HALF_UP).doubleValue();
                    }
                    
                    double[] values = {punchDays,punchHours,avgHours};
                    result.put(userNum+":"+userName, values);
                    
                    if(single){// 单月的特殊处理
                        addMessage("员工:" + userName + "<工号:" + userNum + ">解析完成,出勤情况:" + "D:" + punchDays + ",H:" + punchHours + ",AH:" + avgHours);
                        if(copyWorkBook != null){
                            for(int v=0;v<values.length;v++){
                                copyWorkBook.getSheetAt(0).getRow(i+1).createCell(days+v).setCellValue(values[v]);
                                HSSFCellStyle cellStyle = copyWorkBook.createCellStyle();
                                cellStyle.cloneStyleFrom(copyWorkBook.getSheetAt(0).getRow(i+1).getCell(0).getCellStyle());
                                cellStyle.setFillPattern(XSSFCellStyle.SOLID_FOREGROUND );
                                cellStyle.setFillForegroundColor(IndexedColors.WHITE.getIndex());
                                copyWorkBook.getSheetAt(0).getRow(i+1).getCell(days+v).setCellStyle(cellStyle);
                            }
                        }
                    }
                }
                
                if(single){// 单月的特殊处理
                    // 读写完成操作开始
                    // 写入文件,并关闭写入流
                    addMessage("整在写入数据,请稍后");
                    if(copyWorkBook != null){
                        FileOutputStream out = new FileOutputStream(copyExcelFile);
                        copyWorkBook.write(out);
                        out.close();
                    }

                    // 打开另存为保存对话框,准备获取保存路径
                    JFileChooser fileSaveChooser =  new JFileChooser();

                    fileSaveChooser.setDialogTitle("另存为");
                    fileSaveChooser.setSelectedFile(new File(excelFile.getAbsolutePath().substring(0,excelFile.getAbsolutePath().lastIndexOf("."))+"-计算结果.xls"));
                    String[] saveType = {"xls"};
                    fileSaveChooser.setAcceptAllFileFilterUsed(false);
                    fileSaveChooser.setFileFilter(new FileNameExtensionFilter("*.xls",saveType));
                    int saveResult = fileSaveChooser.showSaveDialog(this);
                    if(saveResult == JFileChooser.APPROVE_OPTION){
                        File saveFile = fileSaveChooser.getSelectedFile();

                        // 将副本复制到指定的保存位置
                        String saveFilePath = saveFile.getAbsolutePath();
                        addMessage("正在保存文件,请稍后->"+saveFilePath);
                        FileUtils.copyFile(copyExcelFile, saveFile);

                        Object[] options = {"打开文件","打开文件所在目录","别烦我,我要自己去找"};
                        int response=JOptionPane.showOptionDialog(this, "文件处理完成,接下来你要进行哪步处理", "操作选择",JOptionPane.YES_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
                        if(0 == response){// 打开文件
                            // 打开文件保存保存的文件
                            addMessage("正在打开文件,请稍后");
                            Desktop.getDesktop().open(saveFile);
                        }else if(1 == response){// 正在打开文件所在目录
                            addMessage("正在打开文件所在目录,请稍后");
                            String[] cmd = new String[5];
                            cmd[0] = "cmd";
                            cmd[1] = "/c";
                            cmd[2] = "start";
                            cmd[3] = " ";
                            cmd[4] = saveFile.getAbsolutePath().substring(0,saveFile.getAbsolutePath().lastIndexOf("\\"));
                            Runtime.getRuntime().exec(cmd);
                        }else{
                            alert("文件解析已完成,任性的你自己去找吧╮(╯▽╰)╭");
                        }
                    }else{
                        // 如果取消保存,则清除所有消息并置空文件头
                        clearMessage();
                        fileName.setText("");
                        // 通知用户当前文件已取消保存
                        addMessage("用户已取消操作");
                    }

                    // 在另存为结束后删除临时副本文件
                    if(copyExcelFile != null){
                        copyExcelFile.delete();
                    }
                }
            }else{
                // excel中不包含员工信息,那么提示不存在员工信息当前程序结束
                alert("当前的文件中不包含员工考勤记录信息!");
            }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(PunchCardRecordsMainFrame.class.getName()).log(Level.SEVERE, null, ex);
            alert("文件未找到,请检查文件是否已被删除或者移动位置");
        } catch (IOException | OfficeXmlFileException ex) {
            Logger.getLogger(PunchCardRecordsMainFrame.class.getName()).log(Level.SEVERE, null, ex);
            alert("文件读写异常:"+ex.getMessage());
        }
        return result;
    } 
    
    /**
     * 添加状态信息
     * @param message 添加的消息
     */
    private void addMessage(String message){
        System.out.print(message+"...");
        //String originalText = statusView.getText();
        //statusView.setText(originalText+message+"...\r\n");
    }
    
    /**
     * 清除状态信息
     */
    private void clearMessage(){
        printStream.clear();
        statusView.setText("");
        progressBar.setValue(0);
        progressBar.setString("尚未开始解析任何文件");
    }
    
    
    /**
     * 初始化方法,创建窗体
     */
    public static void instance() {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(PunchCardRecordsMainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new PunchCardRecordsMainFrame().init();
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel copyRight;
    private javax.swing.JLabel doWithLabel;
    private javax.swing.JLabel fileName;
    private javax.swing.JLabel infoBottom;
    private javax.swing.JMenu menuAbort;
    private javax.swing.JMenuBar menuBar;
    private javax.swing.JMenu menuFile;
    private javax.swing.JMenuItem menuItemInfo;
    private javax.swing.JScrollPane parseInfoPanel;
    private javax.swing.JProgressBar progressBar;
    private javax.swing.JMenuItem singleMonth;
    private javax.swing.JTextArea statusView;
    private javax.swing.JMenuItem wholeYear;
    // End of variables declaration//GEN-END:variables
    private CommonPrintStream printStream;
    private Abort abort;
}
